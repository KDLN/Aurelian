import { prisma } from '../utils/prisma';

export class GuildCleanupService {
  private isRunning = false;
  private intervalId?: NodeJS.Timeout;

  constructor() {
    console.log('Guild Cleanup Service initialized');
  }

  // Start the cleanup service
  start() {
    if (this.isRunning) {
      console.log('Guild cleanup service is already running');
      return;
    }

    this.isRunning = true;
    console.log('Starting guild cleanup service...');

    // Run immediately on start
    this.runCleanup().catch(error => {
      console.error('Initial cleanup failed:', error);
    });

    // Schedule to run every 4 hours
    this.intervalId = setInterval(() => {
      this.runCleanup().catch(error => {
        console.error('Scheduled cleanup failed:', error);
      });
    }, 4 * 60 * 60 * 1000); // 4 hours in milliseconds
  }

  // Stop the cleanup service
  stop() {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }
    console.log('Guild cleanup service stopped');
  }

  // Main cleanup method
  private async runCleanup() {
    const startTime = Date.now();
    console.log('üßπ Starting guild cleanup tasks...');

    try {
      const results = await this.performCleanupTasks();
      
      const duration = Date.now() - startTime;
      console.log(`‚úÖ Guild cleanup completed in ${duration}ms:`, results);

      // Log cleanup results to database
      await this.logCleanupResults(results, duration);

    } catch (error) {
      console.error('‚ùå Guild cleanup failed:', error);
      
      // Log the failure
      await this.logCleanupFailure(error as Error);
    }
  }

  private async performCleanupTasks() {
    const results: Record<string, any> = {};

    // 1. Clean expired invitations
    results.expiredInvitations = await this.cleanExpiredInvitations();

    // 2. Update member activity status
    results.memberActivity = await this.updateMemberActivity();

    // 3. Clean old logs
    results.oldLogs = await this.cleanOldLogs();

    // 4. Handle abandoned guilds
    results.abandonedGuilds = await this.handleAbandonedGuilds();

    // 5. Clean expired alliances
    results.expiredAlliances = await this.cleanExpiredAlliances();

    // 6. Archive old messages
    results.archivedMessages = await this.archiveOldMessages();

    return results;
  }

  private async cleanExpiredInvitations() {
    const now = new Date();
    
    const result = await prisma.guildInvite.deleteMany({
      where: {
        expiresAt: { lt: now }
      }
    });

    return { deletedCount: result.count };
  }

  private async updateMemberActivity() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    // Find inactive members (excluding leaders)
    const inactiveMembers = await prisma.guildMember.findMany({
      where: {
        lastActive: { lt: thirtyDaysAgo },
        role: { not: 'LEADER' }
      },
      take: 100 // Process in batches
    });

    let loggedCount = 0;

    // Log inactivity for tracking
    for (const member of inactiveMembers) {
      try {
        await prisma.guildLog.create({
          data: {
            guildId: member.guildId,
            userId: member.userId,
            action: 'member_marked_inactive',
            details: {
              lastActive: member.lastActive,
              daysSinceActive: Math.floor(
                (Date.now() - member.lastActive.getTime()) / (1000 * 60 * 60 * 24)
              ),
              autoGenerated: true
            }
          }
        });
        loggedCount++;
      } catch (error) {
        console.error(`Failed to log inactivity for member ${member.id}:`, error);
      }
    }

    return { 
      inactiveMembersFound: inactiveMembers.length,
      loggedCount 
    };
  }

  private async cleanOldLogs() {
    const thirtyDaysAgo = new Date();
    thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

    const result = await prisma.guildLog.deleteMany({
      where: {
        createdAt: { lt: thirtyDaysAgo },
        // Preserve important logs
        action: {
          notIn: [
            'guild_created',
            'member_joined',
            'member_left',
            'member_promoted',
            'member_demoted',
            'leadership_transferred',
            'guild_deactivated'
          ]
        }
      }
    });

    return { deletedCount: result.count };
  }

  private async handleAbandonedGuilds() {
    const sixtyDaysAgo = new Date();
    sixtyDaysAgo.setDate(sixtyDaysAgo.getDate() - 60);

    // Find potentially abandoned guilds
    const guilds = await prisma.guild.findMany({
      where: {
        isActive: true,
        updatedAt: { lt: sixtyDaysAgo }
      },
      include: {
        members: {
          where: { role: 'LEADER' }
        },
        logs: {
          where: {
            createdAt: { gt: sixtyDaysAgo }
          },
          take: 1
        }
      },
      take: 50 // Process in batches
    });

    let deactivatedCount = 0;

    for (const guild of guilds) {
      // No leaders and no recent activity = abandoned
      if (guild.members.length === 0 && guild.logs.length === 0) {
        try {
          await prisma.$transaction(async (tx) => {
            // Deactivate the guild
            await tx.guild.update({
              where: { id: guild.id },
              data: { isActive: false }
            });

            // Log the deactivation
            await tx.guildLog.create({
              data: {
                guildId: guild.id,
                action: 'guild_auto_deactivated',
                details: {
                  reason: 'abandoned_no_leaders_no_activity',
                  lastUpdate: guild.updatedAt,
                  memberCount: guild.members.length,
                  autoGenerated: true
                }
              }
            });
          });

          deactivatedCount++;
        } catch (error) {
          console.error(`Failed to deactivate guild ${guild.id}:`, error);
        }
      }
    }

    return { 
      checkedGuilds: guilds.length,
      deactivatedCount 
    };
  }

  private async cleanExpiredAlliances() {
    const now = new Date();

    const result = await prisma.guildAlliance.deleteMany({
      where: {
        expiresAt: { lt: now }
      }
    });

    return { deletedCount: result.count };
  }

  private async archiveOldMessages() {
    const ninetyDaysAgo = new Date();
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);

    // Delete old guild messages (except pinned ones)
    const result = await prisma.chatMessage.deleteMany({
      where: {
        createdAt: { lt: ninetyDaysAgo },
        channelType: 'GUILD',
        // Don't delete pinned messages
        NOT: {
          metadata: {
            path: ['pinned'],
            equals: true
          }
        }
      }
    });

    return { archivedCount: result.count };
  }

  private async logCleanupResults(results: Record<string, any>, duration: number) {
    try {
      // Log to a system log table or external service
      // For now, we'll just use console logging
      console.log('Cleanup completed:', {
        timestamp: new Date().toISOString(),
        duration,
        results
      });
    } catch (error) {
      console.error('Failed to log cleanup results:', error);
    }
  }

  private async logCleanupFailure(error: Error) {
    try {
      console.error('Cleanup failure logged:', {
        timestamp: new Date().toISOString(),
        error: error.message,
        stack: error.stack
      });
    } catch (logError) {
      console.error('Failed to log cleanup failure:', logError);
    }
  }

  // Get cleanup statistics
  async getCleanupStats() {
    const now = new Date();
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);

    try {
      return {
        expiredInvitations: await prisma.guildInvite.count({
          where: { expiresAt: { lt: now } }
        }),
        
        inactiveMembers: await prisma.guildMember.count({
          where: {
            lastActive: { lt: thirtyDaysAgo },
            role: { not: 'LEADER' }
          }
        }),

        oldLogs: await prisma.guildLog.count({
          where: {
            createdAt: { lt: thirtyDaysAgo },
            action: {
              notIn: [
                'guild_created',
                'member_joined',
                'member_left', 
                'member_promoted',
                'member_demoted',
                'leadership_transferred'
              ]
            }
          }
        }),

        activeGuilds: await prisma.guild.count({
          where: { isActive: true }
        }),

        totalMembers: await prisma.guildMember.count(),

        lastCleanupTime: new Date().toISOString(),
        status: this.isRunning ? 'running' : 'stopped'
      };
    } catch (error) {
      console.error('Error getting cleanup stats:', error);
      throw error;
    }
  }
}

// Singleton instance
export const guildCleanupService = new GuildCleanupService();